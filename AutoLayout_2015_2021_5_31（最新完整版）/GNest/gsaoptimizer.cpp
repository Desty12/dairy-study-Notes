#include "GSAOptimizer.h"
#include <time.h>
#include "gautolayout.h"

#define e 2.718

GSAOptimizer::GSAOptimizer()
{
	//maxTemperature = 800000.0;
	maxTemperature = 750.0;
	minTemperature = 1.0;
	saPerIters = 1;
	mControlA = 0.9359;

	mIsAbort = false;
}

GSAOptimizer::~GSAOptimizer()
{
}


double GSAOptimizer::optimize(int maxIter,							// 最大迭代次数
	double maxLayoutRate,					// 最大排版率
	QVector< GPart > &nestParts,			// 排样零件
	QVector<int> &usedPageNums,				// 板材使用数量
	QVector<int> &plateIndices,				// 板材索引
	double &layoutRate,						// 排版率
	int *pProgress)
{
	QVector<QList<QVector<int> > >		globalBestSeq;				// 全局最优排序结果
	double								globalBestRating = 0.0;		// 全局最优排版率
	int									globalBestFLen = 100000000;
	double								globalBestFirstPageHeight;	// 全局最优时第一页排版高度
	QVector<QList<QVector<int> > >		localBestSeq;				// 局部最优排序结果
	double								localBestRating = 0.0;		// 局部最优排序结果
	int									localBestFLen = 100000000;
	double								localBestFirstPageHeight;	// 局部最优排序结果
	quint32								selectMark = 0x01;			// 随机调整零件的旗标

	int   isSameNum = 0;
	srand((unsigned)time(NULL));
	// 模拟退火算法主体

	localBestSeq = mClusterGroups;
	QVector<quint32>	rotFlags0;
	QVector<GPart>		tmpNestParts;
	QVector<int>		pageNum;
	QVector<int>		plateNum;
	nestParts.clear();
	usedPageNums.clear();
	plateIndices.clear();

	layout(localBestSeq, tmpNestParts, pageNum, plateNum, localBestRating, localBestFirstPageHeight, localBestFLen);

	QVector<int>	tempSorts0;
	groupsSeq2Seq(localBestSeq, tempSorts0);

	SaveLayoutDatas saveDatas0;
	saveDatas0.nestRating = localBestRating;
	saveDatas0.firstPageNestHeight = localBestFirstPageHeight;
	saveDatas0.lastPageForwardLines = localBestFLen;

	mRecordLayoutSeQ.insert(tempSorts0, saveDatas0);

	nestParts = tmpNestParts;
	usedPageNums = pageNum;
	plateIndices = plateNum;
	layoutRate = localBestRating;
	plateNum.clear();
	pageNum.clear();
	tmpNestParts.clear();
	tempSorts0.clear();

	globalBestSeq = localBestSeq;
	globalBestRating = localBestRating;
	globalBestFLen = localBestFLen;
	globalBestFirstPageHeight = localBestFirstPageHeight;

	int perIterm = 0;			// 统计迭代次数

	double  tempData = round((log(minTemperature) - log(maxTemperature)) / log(mControlA));
	saPerIters = ceil(maxIter / tempData);

	double t = maxTemperature;
	int aiter = 0;
	while (t > minTemperature && aiter < maxIter)
	{
		aiter++;
		for (int iter = 0; iter < saPerIters && (!mIsAbort); iter++)
		{
			if (pProgress) // 计算目前的迭代进度
			{
				*pProgress = qRound((perIterm + 1) * 100.0 / maxIter);
			}
			QVector< GPart >	tmnestParts;
			QVector<int>		tmusedPageNums;
			QVector<int>		tmplateIndices;

			QVector<QList<QVector<int> > >	tmpSeq;			// 临时零件排版序列
			double							tmpRating;		// 临时零件排版率
			int								tmpFLen;		
			double							tmpFirstPageHeight;
			tmpSeq = mClusterGroups;
			int bigNums = 0;
			int allGroupsNum = 0;
			for (int i = 0; i < mClusterGroups.count(); i++)
			{
				allGroupsNum += mClusterGroups[i].count();
			}

			double  minvalue = 2 / allGroupsNum*1.0;
			double  tempValue = 0.66 - minvalue;

			if (perIterm < 0.7*maxIter) bigNums = ceil((0.66 - (tempValue / maxIter)*perIterm)*allGroupsNum);
			else bigNums = 2;

			if (bigNums >= allGroupsNum) bigNums = ceil(0.66*allGroupsNum);
			else if (bigNums <= 0) bigNums = 1;

			// 0x01表示随机调整一个小组，0x02表示对一个小组进行略微调整，
			// 0x04和0x08表示任意交换一个小组内的两个数据
			if (perIterm > ceil(0.8*maxIter)) // 零件迭代到后期将只对一个大组内的小组零件进行调整
			{
				bigNums = 1;
				selectMark = 0x01;
			}
			changeGroupsDatas(tmpSeq, bigNums, selectMark, true);

			QVector<int>	tmpSequence;
			groupsSeq2Seq(tmpSeq, tmpSequence);
			selectMark <<= 1;
			if (selectMark > 0x08) selectMark = 0x01;

			bool isSame = false;
			double  markRating = 0.0;
			int		markFLen = 0;

			QHash<QVector<int>, SaveLayoutDatas >::iterator hashIter = mRecordLayoutSeQ.find(tmpSequence);
			if (hashIter != mRecordLayoutSeQ.end())
			{
				markRating = hashIter->nestRating;
				markFLen = hashIter->lastPageForwardLines;
				isSame = true;
			}

			if (isSame)
			{
				tmpRating = markRating;
				tmpFLen = markFLen;
				isSameNum++;
				//printf("\n第%d次，在hash表中找到相同序列\n\n", isSameNum);
			}
			else
			{
				layout(tmpSeq, tmnestParts, tmusedPageNums, tmplateIndices, tmpRating, tmpFirstPageHeight, tmpFLen);
				SaveLayoutDatas saveDatasTmp;
				saveDatasTmp.nestRating = tmpRating;
				saveDatasTmp.firstPageNestHeight = tmpFirstPageHeight;
				saveDatasTmp.lastPageForwardLines = tmpFLen;

				mRecordLayoutSeQ.insert(tmpSequence, saveDatasTmp);
			}

			float  dE = tmpRating - localBestRating;
			if (dE > 1e-6)
			{
				localBestSeq = tmpSeq;
				localBestRating = tmpRating;
				localBestFLen = tmpFLen;
				localBestFirstPageHeight = tmpFirstPageHeight;
			}
			else
			{
				double P = exp(dE / (t));
				// printf("根据当前温度计算的概率%f\n",P);

				double tmpRandom = (rand() % 1000 / 1000.0);
				if (P > tmpRandom)
				{
					localBestSeq = tmpSeq;
					localBestRating = tmpRating;
					localBestFLen = tmpFLen;
					localBestFirstPageHeight = tmpFirstPageHeight;
				}
			}

			if (//localBestRating > globalBestRating ||
				((localBestRating - globalBestRating) > 1e-4 )|| (fabs(localBestRating - globalBestRating) < 1e-4 && localBestFLen < globalBestFLen))
			{
				globalBestSeq = localBestSeq;
				globalBestRating = localBestRating;
				globalBestFLen = localBestFLen;
				globalBestFirstPageHeight = localBestFirstPageHeight;
				layoutRate = globalBestRating;

				nestParts = tmnestParts;
				usedPageNums = tmusedPageNums;
				plateIndices = tmplateIndices;

				// 如果达到最大排版率直接退出迭代
				if (globalBestRating > maxLayoutRate)
					return globalBestFirstPageHeight;
			}
			printf("迭代第%d次时，当前零件的全局最优排版率为：%f, %d\t,局部最优排版率为：%f, %d\n", 
				perIterm + 1, globalBestRating, globalBestFLen, localBestRating, localBestFLen);

			perIterm++;
		}// end for

		 // 强制结束迭代寻优
		if (mIsAbort) return globalBestFirstPageHeight;

		t = t * mControlA; // 执行降温操作
	}// end while

	printf("打印总的迭代次数%d\n", perIterm);
	mRecordLayoutSeQ.clear();
	// 用于测试大小组显示情况
	/*layoutOrders.clear();
	for (int i = 0; i < globalBestSeq.count(); i++)
	{
	for (int j = 0; j < globalBestSeq[i].count(); j++)
	{
	for (int k = 0; k < globalBestSeq[i][j].count(); k++)
	{
	layoutOrders.append(globalBestSeq[i][j][k]);
	}
	}
	}*/
}

const QVector<int>	& GSAOptimizer::getLayoutSequence() const
{
	return layoutOrders;
}